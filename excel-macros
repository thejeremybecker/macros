Sub CreateSheetsFromAList()
' Make copies of "Master" tab and rename to cells in range beginning in 'RCM cell A5'
' Only loops through visible rows (hidden rows do not get tabs created)
' Named ranges can create error (click-through) when ranges are duplicated. To resolve, delete named ranges first in Name Manager.

'Be sure 'Master (2)' sheet does not exist first.
'Reset VBA project first to clear any variables (Reset/stop button in VBA editor)'

    Dim ws1 As Worksheet
    Set ws1 = ThisWorkbook.Worksheets("Master")

    Dim MyCell As Range, MyRange As Range

    Set MyRange = Sheets("RCM").Range("A8")
    Set MyRange = Range(MyRange, MyRange.End(xlDown))

    For Each MyCell In MyRange
      If MyCell.EntireRow.Hidden = False Then 'only includes non-hidden rows
        ws1.Copy ThisWorkbook.Sheets(Sheets.Count)
        ThisWorkbook.Worksheets("Master (2)").Name = MyCell.Value 'renames sheets to match row in RCM
      End If
       
    Next MyCell

End Sub

Sub NameCellAsTabName()

'Rename cell "C7" on each sheet to tab name
'Names cell C7 on sheets with 'index' greater than 3 (fourth sheet)

Dim ws As Worksheet

For Each ws In ActiveWorkbook.Worksheets
      If ws.Index > 3 Then 'renames sheets with index greater than 3
        ws.Range("C7") = ws.Name 'renames cell C7 to match sheet name
      End If
Next

End Sub

Sub SplitMergedCells()
'this will find all merged cells on
'the currently selected worksheet and then
'unmerge them, placing the text that was
'in them when merged into each individual
'cell and set the alignment to LEFT
'
'see this site for instructions on placing
'this code into your workbook:
' http://www.contextures.com/xlvba01.html#Regular

  Dim myWS As Worksheet
  Dim myCells As Range
  Dim anyCell As Range
  Dim mergedCells As Range
  Dim mCell As Range
  Dim cellText As String
 
  Set myWS = ActiveSheet
  Set myCells = myWS.UsedRange
  For Each anyCell In myCells
    If anyCell.MergeCells Then
      cellText = anyCell.Value
      Set mergedCells = anyCell.MergeArea
      anyCell.MergeCells = False
      For Each mCell In mergedCells
        mCell = cellText
        mCell.HorizontalAlignment = xlLeft
      Next
      Set mergedCells = Nothing
    End If
  Next
  Set myCells = Nothing
  Set myWS = Nothing
  MsgBox "All Merged Cells are now Unmerged", _
   vbOKOnly + vbInformation, "Task Completed"
End Sub

Sub FillCellsFromAbove()

'macro to fill blank cells in selection with values from above

'A non macro solution for filling in empty cells with the content
'of the cell above each from within the selection range. You don't need a macro.
'Make a selection (Multiple columns, for instance) F5 Special,
'goto blanks in the formula bar add =A1 then press Ctrl + Enter
'(Ctrl + D, fill down would also work) reselect the original range in order to
'convert formulas Copy with Ctrl+C Edit, Paste Special, Values Â 

'Explanation -- if one is needed: You can choose any selection area including multiple columns.
'When you pick out the blanks with Special cells the active cell will be the first blank cell
'and you use the cell above it in the formula. Special Cells restricts itself to the Used Area
'so you can select multiple columns if you like and not be concerned that the entire column is
'mostly unused.


    Application.ScreenUpdating = False ' Turn off screen updating to improve performance
    On Error Resume Next
    
    With Columns(1) ' Look in column A
        .SpecialCells(xlCellTypeBlanks).Formula = "=R[-1]C" ' For blank cells, set them to equal the cell above
        .Value = .Value 'Convert the formula to a value
    End With
    Err.Clear
    Application.ScreenUpdating = True
End Sub

Sub SeparateNames()
'Macro to split cells into new rows based on line breaks - column C contains the rows to be split.

Dim lLastRow As Long
Dim vArr1 As Variant, vArr2 As Variant, vArr3 As Variant
lLastRow = Range("C" & Rows.Count).End(xlUp).Row
On Error Resume Next
  For i = lLastRow To 2 Step -1
    vArr1 = Split(Range("C" & i).Value, Chr(10))
    vArr2 = Split(Range("D" & i).Value, Chr(10))
    vArr3 = Split(Range("E" & i).Value, Chr(10))
    Range("C" & i).Offset(1, 0).Resize(UBound(vArr1), 1).EntireRow.Insert Shift:=xlUp
    Range("C" & i).Resize(UBound(vArr1) + 1, 1).Value = Application.Transpose(vArr1)
    Range("D" & i).Resize(UBound(vArr2) + 1, 1).Value = Application.Transpose(vArr2)
    Range("E" & i).Resize(UBound(vArr3) + 1, 1).Value = Application.Transpose(vArr3)
Next i

End Sub

Sub SliceNDice()

'Macro to add rows for comma separated values
'This takes comma separated value and adds rows (records) for each unique csv value'

    Dim objRegex As Object
    Dim X
    Dim Y
    Dim lngRow As Long
    Dim lngCnt As Long
    Dim tempArr() As String
    Dim strArr
    Set objRegex = CreateObject("vbscript.regexp")
    objRegex.Pattern = "^\s+(.+?)$"
     'Define the range to be analysed
    X = Range([a1], Cells(Rows.Count, "d").End(xlUp)).Value2
    ReDim Y(1 To 4, 1 To 1000)
    For lngRow = 1 To UBound(X, 1)
         'Split each string by ","
        tempArr = Split(X(lngRow, 4), ",")
        For Each strArr In tempArr
            lngCnt = lngCnt + 1
             'Add another 1000 records to resorted array every 1000 records
            If lngCnt Mod 1000 = 0 Then ReDim Preserve Y(1 To 4, 1 To lngCnt + 1000)
            Y(1, lngCnt) = X(lngRow, 1)
            Y(2, lngCnt) = X(lngRow, 2)
            Y(3, lngCnt) = X(lngRow, 3)
            Y(4, lngCnt) = objRegex.Replace(strArr, "$1")
        Next
    Next lngRow
     'Dump the re-ordered range to columns E:H
    [e1].Resize(lngCnt, 4).Value2 = Application.Transpose(Y)
    ActiveSheet.Range("E:H").RemoveDuplicates Columns:=Array(1, 2, 3, 4), _
        Header:=xlNo
End Sub

Sub links_to_text()
'replaces links with text hyperlink location

Dim Cell As Range
For Each Cell In Intersect(Selection, ActiveSheet.UsedRange)
    If Cell.Hyperlinks.Count > 0 Then
        Cell.Value = Cell.Hyperlinks.Item(1).Address
    End If
Next
End Sub


Sub OutsideBorderOnly()
'removes all borders from selection and applies outside border to selection
'shortcut key Ctrl + Shift + O

   With Selection.Borders(xlDiagonalDown).LineStyle = xlNone
   End With
   
   With Selection.Borders(xlDiagonalUp).LineStyle = xlNone
   End With
   
    With Selection.Borders(xlEdgeLeft).LineStyle = xlNone
    End With
    
   With Selection.Borders(xlEdgeTop).LineStyle = xlNone
   End With
   
   With Selection.Borders(xlEdgeBottom).LineStyle = xlNone
   End With
   
   With Selection.Borders(xlEdgeRight).LineStyle = xlNone
   End With
   
   With Selection.Borders(xlInsideVertical).LineStyle = xlNone
   End With
   
   With Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
   End With
   
   With Selection.Borders(xlDiagonalDown).LineStyle = xlNone
   End With
   
   With Selection.Borders(xlDiagonalUp).LineStyle = xlNone
   End With
   
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    Selection.Borders(xlInsideVertical).LineStyle = xlNone
    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
End Sub

Sub ShowSheetLists()

  Application.CommandBars("Workbook tabs").ShowPopup

End Sub
    
